# Chris_ID

根据《可伸缩服务架构+中间件》学习，实现一个简单的分布式ID生成器（由简至繁层层递进）

通过目录结构来展示版本迭代的关系
* v1版本实现了简单的单机毫秒级的本地ID生成器。
* v2版本实现本地可配置ID生成器
* v3版本实现ID生成器服务，其中除去上述功能外：
    * 服务端支持批量生成ID，客户端对生成的结果ID进行结果缓存，从而提高性能。 todo
    * 服务端机器需要定时于时间服务器进行同步，可在服务器中进行定时任务配置 todo
    ```
        ntpdate -u
    ```
    * 当服务端重启后需要设置延迟启动发号服务，优先将原时间戳预热，防止重启期间更新的时间早于原当前时间。todo
    * 多个客户端对服务端的SequenceConfig存在差异化，id生成策略依照客户端的不同而不同


> 下文为笔记部分

## 为什么不
* 为什么不用UUID
    * 存储占用完全的时间数据，存储性能差
* 为什么不用数据自增ID
    * ID依赖数据库会在数据库迁移、扩容、数据清洗、分库分表的时候遇到很多麻烦。
* 为什么不用snowFlake
    * 原因需要进一步探索 **todo**
> 互联网相比银行，数据存在伸缩扩容的情况很频繁，因此自增ID不可取

## 我们的需求
* 全局唯一
* 粗略有序：一般要么秒级有序，要么毫秒级有序。
* 可反解
* 可制造：即可复现旧ID
* 高性能
* 高可用
* 可伸缩

---

> 那么设计一个IDGenerator的时候都需要考虑哪些因素呢？

## 设计核心要点

### 发布模式

指用户使用的方式，比如**提供本地客户端（jar包）调用本地实现**、**提供本地客户端调用外部服务**或者**RESTful调用外部服务**。

> 根据业务需要，发布模式也可以体现在ID中体现。
> 思考，这三种发布模式的利弊各在哪里？
> * 本地客户端调用本地实现：需要自行配置机器节点ID，优点是ID发布去中心化，不存在宕机风险，本地生成ID无需网络IO，快；缺点是ID难以统一维护
> * 本地客户端调用远程服务：优点是ID服务便于统一维护升级，缺点是远程调用需解决网络IO延迟问题。
> * RESTFul调用：除去上述优点之外还有一个支持跨平台应用调用，缺点同上。

### 数据结构

在ID的设计结构里，我们通常都需要考虑
* 版本或扩展位，用于id生成器的版本迭代或用于扩展。
* ID类型，用于表示秒级有序或者是毫秒级有序或者其他类型。
* ID生成方式，这里用于发布模式的表示。
* 时间，**核心结构**，秒级时间或毫秒级时间。
* 序列号，**核心结构**，与时间一起保证ID有序
* 机器ID，一个节点为一个ID，标识发布ID的机器节点。

秒级有序结构

字段|版本|类型|生成方式|秒级时间|序列号|机器ID
---|---|---|---|---|---|---
位数|63|62|60-61|30-59|10-29|0-9

毫秒级有序结构
字段|版本|类型|生成方式|秒级时间|序列号|机器ID
---|---|---|---|---|---|---
位数|63|62|60-61|20-59|10-19|0-9

> 这里我们可以对比下秒级有序和毫秒级有序的区别：
> * 首先秒级有序的时间跨度为（年）
> ```math
> \frac{2^{30}}{365 \times 60 \times 60} = 34
> ```
> 而毫秒级的时间跨度为
> ```math
> \frac{2^{40}}{1000 \times 60 \times 60 \times 365} = 34
> ```
> 可容纳的时间跨度一致。
> * 再结合序列来考虑即单机并发下每秒的ID生成数。在毫秒级场景下，单位毫秒内可最多产生2^10=1024个ID 。而秒级场景下，单位秒内可最多产生2^20=1048576个ID。**相对来说秒级场景下对峰值下的ID承受能力更强**
>


### 并发

在ID生成过程中需要解决时间+序列的竞争问题
* 通过concurrent包的ReentrantLock锁实现
* 通过synchronized实现
* 通过Atomic原子变量实现

### 机器ID的分配方式

机器ID需要统一管理，以保证ID序列不冲突，分配模式有

* 通过在发号服务器上注册IP信息
* 客户端自行配置

> 通常通过ZK在进行机器ID生成

### 时间同步

时间同步需要注意的问题有：
* 单机调整时间如何避免对ID生成产生影响
* 每4年原子时钟和电子时钟会有1秒误差，即电子时钟每4年会慢原子时钟一秒如何解决

#### 要点

* 首先服务器集群均需要通过时间服务器同步时间，通过crontab 定时执行：

> ntpdate -u 时间服务器

* 若时间调整快于当前时间，则对ID生成无影响。
* 其次为避免单机场景下因为时间调整后早于当前时间导致ID重复生成ID现象，：**生成ID时需记录原ID并进行比较，出现回退情况则拒绝生成ID**。
* 对于发号服务器重启过程中出现时间调整早于当前时间且无原ID记录。则需**保证重启后的时间要晚于原当前时间**（可以通过延迟启动服务等）
* 对于闰秒问题定时同步时间服务器即可。


## 设计部分

> Taik Is Cheap, Show Me Code

[见练习代码](https://chouney.github.com/study)

设计一个场景下的IDGenerator不仅仅需要满足ID生成需求，同样也需要支持ID反编译、ID回溯。
